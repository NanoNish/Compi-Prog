STL:
1. Algorithms
2. Containers

Containers:
1. Vectors
2. List
3. Deque
4. Bitsets
5. Sets
6. Map
7. Stack
8. Queue
9. Priority Queue
10. Multiset

Vectors List and Deque are sequential containers
Sets Map Multiset are associative containers

Vectors:
    basically resizable array
    vector<datatype> vector_name(size)
    v.pb() ie v.push_back()
    v.pop_back()
    v.size()
    v.empty()
    v.back()

Iterator: pointer used to traverse through Containers
    eg v.begin(), v.end()
    can also be incremented or decremented ie it++ or it--

sort( , ) --> 2 compulsory parameters: starting pointer annd ending pointer + 1 ie v.begin() and v.end()
    a third parameter ie greater<int>() is a comparator which can be used to sort in opposite trend
    sort(v.rbegin(), v.rend()) also sorts in opposite trend: rbegin() points at last element and rend() at first element - 1

Deque:
    Double Ended Queue
    deque<int> d
    kind of like vectors but insertion and deletion is possible from both sides
    d.push_back() is pushing from back
    d.push_front() is pushing from push_front
    d.pop_back() and d.pop_front() work in similar way

All insertions and deletions from ends is O(1) while erasing from between takes O(n)

List:
    insertion everywhere is O(1): list.insert(it, value)

Sets:
    only unique values are stored in increasing manner only
    set<int> s
    s.insert(value)
    Red-Black Trees: it is a self balancing binary search tree 
    2 types of set: Set, Unordered-Set (Hashtables used in this type)
    Set works in O(log n) and Unordered Set in O(1) but can take O(n) in worst case
    s.find(value) returns an iterator pointing to the value or at end if value not present
    s.erase(it)

Multisets:
    Say we inserted '1' 4 times, '2' 3 times and '3' 2 times then multiset is [1,1,1,1,2,2,2,3,3]
    let it point at 4th 1, s.erase(*it) removes all 1s while s.erase(s.find(*it)) erases just one single 1
    
Maps:
    basically like dictionary in Python
    stored in ascending order of keys
    key is always unique
    insertion, searching and deletion all takes O(log n)
    it works on Red Black Trees as well
    Unordered map also exists, it works on Hashtables and in woorst case can take O(n)

Stack:
    LIFO ie Last In First Out
    stack<int> s
    s.push(1); s.push(2); s.push(3); x = s.top() --> x == 3
    pushing and top takes O(1)

Priority Queue:
    uses Heaps

Algorithms:

1. GCD: gcd(a,b)
2. LCM: lcm(a,b)
3. max_element: returns it
4. min_element: returns it
// 5, 6, 7 and 8 needs to be sorted before being used
5. lower_bound: lower_bound(a,b,val) returns it to value y st y >= val in [a,b) or returns end
6. upper_bound: upper_bound(a,b,val) returns it to y st y > val in [a,b) 
7. binary_search: binary_search(v.begin(), v.end(), val) returns true or false
8. next_permutation: gives next permutation lexicographically, takes O(n!)

Bitset:
    bitset vbasically optimizes the bit versions or bit strings
    however the size needs to be known during compilation
    eg bitset<M> bset(string("1100")) gives 00000000000000000000000000001100
    bitset[1] = 1 changes the 2nd from right 